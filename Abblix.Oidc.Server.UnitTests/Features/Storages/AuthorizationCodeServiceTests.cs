// Abblix OIDC Server Library
// Copyright (c) Abblix LLP. All rights reserved.
//
// DISCLAIMER: This software is provided 'as-is', without any express or implied
// warranty. Use at your own risk. Abblix LLP is not liable for any damages
// arising from the use of this software.
//
// LICENSE RESTRICTIONS: This code may not be modified, copied, or redistributed
// in any form outside of the official GitHub repository at:
// https://github.com/Abblix/OIDC.Server. All development and modifications
// must occur within the official repository and are managed solely by Abblix LLP.
//
// Unauthorized use, modification, or distribution of this software is strictly
// prohibited and may be subject to legal action.
//
// For full licensing terms, please visit:
//
// https://oidc.abblix.com/license
//
// CONTACT: For license inquiries or permissions, contact Abblix LLP at
// info@abblix.com

using System;
using System.Threading.Tasks;
using Abblix.Oidc.Server.Common;
using Abblix.Oidc.Server.Common.Constants;
using Abblix.Oidc.Server.Endpoints.Token.Interfaces;
using Abblix.Oidc.Server.Features.RandomGenerators;
using Abblix.Oidc.Server.Features.Storages;
using Abblix.Oidc.Server.Features.UserAuthentication;
using Abblix.Oidc.Server.UnitTests.TestInfrastructure;
using Moq;
using Xunit;

namespace Abblix.Oidc.Server.UnitTests.Features.Storages;

/// <summary>
/// Unit tests for <see cref="AuthorizationCodeService"/> verifying authorization code
/// lifecycle management per OAuth 2.0 specification.
/// </summary>
public class AuthorizationCodeServiceTests
{
    private readonly Mock<IAuthorizationCodeGenerator> _codeGenerator;
    private readonly Mock<IEntityStorage> _storage;
    private readonly Mock<IEntityStorageKeyFactory> _keyFactory;
    private readonly AuthorizationCodeService _service;

    public AuthorizationCodeServiceTests()
    {
        _codeGenerator = new Mock<IAuthorizationCodeGenerator>(MockBehavior.Strict);
        _storage = new Mock<IEntityStorage>(MockBehavior.Strict);
        _keyFactory = new Mock<IEntityStorageKeyFactory>(MockBehavior.Strict);

        // Setup key factory to return expected key format
        _keyFactory
            .Setup(kf => kf.AuthorizedGrantKey(It.IsAny<string>()))
            .Returns<string>(code => $"Abblix.Oidc.Server:Grant:{code}");

        _service = new AuthorizationCodeService(
            _codeGenerator.Object,
            _storage.Object,
            _keyFactory.Object);
    }

    private static AuthorizedGrant CreateGrant()
    {
        var session = new AuthSession(
            Subject: "user_123",
            SessionId: "session_123",
            AuthenticationTime: DateTimeOffset.UtcNow,
            IdentityProvider: "local");

        var context = new AuthorizationContext(
            clientId: TestConstants.DefaultClientId,
            scope: [],
            requestedClaims: null);

        return new AuthorizedGrant(session, context);
    }

    /// <summary>
    /// Verifies that GenerateAuthorizationCodeAsync returns the code generated by the generator.
    /// Per OAuth 2.0, authorization code must be unique and cryptographically secure.
    /// </summary>
    [Fact]
    public async Task GenerateAuthorizationCodeAsync_ShouldReturnGeneratedCode()
    {
        // Arrange
        var expectedCode = "auth_code_123";
        var grant = CreateGrant();
        var expiresIn = TimeSpan.FromMinutes(10);

        _codeGenerator
            .Setup(g => g.GenerateAuthorizationCode())
            .Returns(expectedCode);

        _storage
            .Setup(s => s.SetAsync(
                It.IsAny<string>(),
                It.IsAny<AuthorizedGrant>(),
                It.IsAny<StorageOptions>(),
                It.IsAny<System.Threading.CancellationToken?>()))
            .Returns(Task.CompletedTask);

        // Act
        var result = await _service.GenerateAuthorizationCodeAsync(grant, expiresIn);

        // Assert
        Assert.Equal(expectedCode, result);
    }

    /// <summary>
    /// Verifies that GenerateAuthorizationCodeAsync calls the generator once.
    /// Code generation should delegate to IAuthorizationCodeGenerator.
    /// </summary>
    [Fact]
    public async Task GenerateAuthorizationCodeAsync_ShouldCallGeneratorOnce()
    {
        // Arrange
        var grant = CreateGrant();
        var expiresIn = TimeSpan.FromMinutes(10);

        _codeGenerator
            .Setup(g => g.GenerateAuthorizationCode())
            .Returns("code_123");

        _storage
            .Setup(s => s.SetAsync(
                It.IsAny<string>(),
                It.IsAny<AuthorizedGrant>(),
                It.IsAny<StorageOptions>(),
                It.IsAny<System.Threading.CancellationToken?>()))
            .Returns(Task.CompletedTask);

        // Act
        await _service.GenerateAuthorizationCodeAsync(grant, expiresIn);

        // Assert
        _codeGenerator.Verify(g => g.GenerateAuthorizationCode(), Times.Once);
    }

    /// <summary>
    /// Verifies that GenerateAuthorizationCodeAsync stores grant with correct key format.
    /// Key format should be "authorizationCode:{code}" for storage consistency.
    /// </summary>
    [Fact]
    public async Task GenerateAuthorizationCodeAsync_ShouldUseCorrectKeyFormat()
    {
        // Arrange
        var code = "test_code";
        var grant = CreateGrant();
        var expiresIn = TimeSpan.FromMinutes(10);
        string? capturedKey = null;

        _codeGenerator
            .Setup(g => g.GenerateAuthorizationCode())
            .Returns(code);

        _storage
            .Setup(s => s.SetAsync(
                It.IsAny<string>(),
                It.IsAny<AuthorizedGrant>(),
                It.IsAny<StorageOptions>(),
                It.IsAny<System.Threading.CancellationToken?>()))
            .Callback<string, AuthorizedGrant, StorageOptions, System.Threading.CancellationToken?>(
                (key, _, _, _) => capturedKey = key)
            .Returns(Task.CompletedTask);

        // Act
        await _service.GenerateAuthorizationCodeAsync(grant, expiresIn);

        // Assert
        Assert.Equal($"Abblix.Oidc.Server:Grant:{code}", capturedKey);
    }

    /// <summary>
    /// Verifies that GenerateAuthorizationCodeAsync stores the grant object.
    /// The grant contains session and context information needed for token exchange.
    /// </summary>
    [Fact]
    public async Task GenerateAuthorizationCodeAsync_ShouldStoreGrant()
    {
        // Arrange
        var code = "code_123";
        var grant = CreateGrant();
        var expiresIn = TimeSpan.FromMinutes(10);
        AuthorizedGrant? capturedGrant = null;

        _codeGenerator
            .Setup(g => g.GenerateAuthorizationCode())
            .Returns(code);

        _storage
            .Setup(s => s.SetAsync(
                It.IsAny<string>(),
                It.IsAny<AuthorizedGrant>(),
                It.IsAny<StorageOptions>(),
                It.IsAny<System.Threading.CancellationToken?>()))
            .Callback<string, AuthorizedGrant, StorageOptions, System.Threading.CancellationToken?>(
                (_, g, _, _) => capturedGrant = g)
            .Returns(Task.CompletedTask);

        // Act
        await _service.GenerateAuthorizationCodeAsync(grant, expiresIn);

        // Assert
        Assert.Same(grant, capturedGrant);
    }

    /// <summary>
    /// Verifies that GenerateAuthorizationCodeAsync sets correct expiration.
    /// Per OAuth 2.0, authorization codes should have short expiration times (typically 10 minutes).
    /// </summary>
    [Fact]
    public async Task GenerateAuthorizationCodeAsync_ShouldSetExpiration()
    {
        // Arrange
        var code = "code_123";
        var grant = CreateGrant();
        var expiresIn = TimeSpan.FromMinutes(10);
        StorageOptions? capturedOptions = null;

        _codeGenerator
            .Setup(g => g.GenerateAuthorizationCode())
            .Returns(code);

        _storage
            .Setup(s => s.SetAsync(
                It.IsAny<string>(),
                It.IsAny<AuthorizedGrant>(),
                It.IsAny<StorageOptions>(),
                It.IsAny<System.Threading.CancellationToken?>()))
            .Callback<string, AuthorizedGrant, StorageOptions, System.Threading.CancellationToken?>(
                (_, _, options, _) => capturedOptions = options)
            .Returns(Task.CompletedTask);

        // Act
        await _service.GenerateAuthorizationCodeAsync(grant, expiresIn);

        // Assert
        Assert.NotNull(capturedOptions);
        Assert.Equal(expiresIn, capturedOptions!.AbsoluteExpirationRelativeToNow);
    }

    /// <summary>
    /// Verifies that multiple calls to GenerateAuthorizationCodeAsync produce unique codes.
    /// Each authorization request should get a unique code.
    /// </summary>
    [Fact]
    public async Task GenerateAuthorizationCodeAsync_MultipleCalls_ShouldProduceUniqueCodes()
    {
        // Arrange
        var grant = CreateGrant();
        var expiresIn = TimeSpan.FromMinutes(10);

        _codeGenerator
            .SetupSequence(g => g.GenerateAuthorizationCode())
            .Returns("code_1")
            .Returns("code_2")
            .Returns("code_3");

        _storage
            .Setup(s => s.SetAsync(
                It.IsAny<string>(),
                It.IsAny<AuthorizedGrant>(),
                It.IsAny<StorageOptions>(),
                It.IsAny<System.Threading.CancellationToken?>()))
            .Returns(Task.CompletedTask);

        // Act
        var code1 = await _service.GenerateAuthorizationCodeAsync(grant, expiresIn);
        var code2 = await _service.GenerateAuthorizationCodeAsync(grant, expiresIn);
        var code3 = await _service.GenerateAuthorizationCodeAsync(grant, expiresIn);

        // Assert
        Assert.NotEqual(code1, code2);
        Assert.NotEqual(code2, code3);
        Assert.NotEqual(code1, code3);
    }

    /// <summary>
    /// Verifies that AuthorizeByCodeAsync returns grant for valid code.
    /// Per OAuth 2.0, valid authorization code should return the stored grant.
    /// </summary>
    [Fact]
    public async Task AuthorizeByCodeAsync_WithValidCode_ShouldReturnGrant()
    {
        // Arrange
        var code = "valid_code";
        var expectedGrant = CreateGrant();

        _storage
            .Setup(s => s.GetAsync<AuthorizedGrant>(
                $"Abblix.Oidc.Server:Grant:{code}",
                false,
                It.IsAny<System.Threading.CancellationToken?>()))
            .ReturnsAsync(expectedGrant);

        // Act
        var result = await _service.AuthorizeByCodeAsync(code);

        // Assert
        Assert.True(result.TryGetSuccess(out var grant));
        Assert.Same(expectedGrant, grant);
    }

    /// <summary>
    /// Verifies that AuthorizeByCodeAsync returns error for invalid code.
    /// Per OAuth 2.0, invalid or expired codes must be rejected.
    /// </summary>
    [Fact]
    public async Task AuthorizeByCodeAsync_WithInvalidCode_ShouldReturnError()
    {
        // Arrange
        var code = "invalid_code";

        _storage
            .Setup(s => s.GetAsync<AuthorizedGrant>(
                $"Abblix.Oidc.Server:Grant:{code}",
                false,
                It.IsAny<System.Threading.CancellationToken?>()))
            .ReturnsAsync((AuthorizedGrant?)null);

        // Act
        var result = await _service.AuthorizeByCodeAsync(code);

        // Assert
        Assert.True(result.TryGetFailure(out var error));
        Assert.NotNull(error);
    }

    /// <summary>
    /// Verifies that AuthorizeByCodeAsync returns InvalidGrant error code.
    /// Per OAuth 2.0, invalid authorization codes should return invalid_grant error.
    /// </summary>
    [Fact]
    public async Task AuthorizeByCodeAsync_WithInvalidCode_ShouldReturnInvalidGrantError()
    {
        // Arrange
        var code = "invalid_code";

        _storage
            .Setup(s => s.GetAsync<AuthorizedGrant>(
                $"Abblix.Oidc.Server:Grant:{code}",
                false,
                It.IsAny<System.Threading.CancellationToken?>()))
            .ReturnsAsync((AuthorizedGrant?)null);

        // Act
        var result = await _service.AuthorizeByCodeAsync(code);

        // Assert
        var error = result.GetFailure();
        Assert.Equal(ErrorCodes.InvalidGrant, error.Error);
    }

    /// <summary>
    /// Verifies that AuthorizeByCodeAsync includes error description.
    /// Error messages help clients understand what went wrong.
    /// </summary>
    [Fact]
    public async Task AuthorizeByCodeAsync_WithInvalidCode_ShouldIncludeErrorDescription()
    {
        // Arrange
        var code = "invalid_code";

        _storage
            .Setup(s => s.GetAsync<AuthorizedGrant>(
                $"Abblix.Oidc.Server:Grant:{code}",
                false,
                It.IsAny<System.Threading.CancellationToken?>()))
            .ReturnsAsync((AuthorizedGrant?)null);

        // Act
        var result = await _service.AuthorizeByCodeAsync(code);

        // Assert
        var error = result.GetFailure();
        Assert.Contains("invalid", error.ErrorDescription, StringComparison.OrdinalIgnoreCase);
    }

    /// <summary>
    /// Verifies that AuthorizeByCodeAsync uses removeOnRetrieval: false.
    /// Code should remain in storage until explicitly removed to prevent replay attacks.
    /// </summary>
    [Fact]
    public async Task AuthorizeByCodeAsync_ShouldNotRemoveOnRetrieval()
    {
        // Arrange
        var code = "test_code";
        var grant = CreateGrant();
        bool? capturedRemoveOnRetrieval = null;

        _storage
            .Setup(s => s.GetAsync<AuthorizedGrant>(
                It.IsAny<string>(),
                It.IsAny<bool>(),
                It.IsAny<System.Threading.CancellationToken?>()))
            .Callback<string, bool, System.Threading.CancellationToken?>(
                (_, remove, _) => capturedRemoveOnRetrieval = remove)
            .ReturnsAsync(grant);

        // Act
        await _service.AuthorizeByCodeAsync(code);

        // Assert
        Assert.False(capturedRemoveOnRetrieval);
    }

    /// <summary>
    /// Verifies that AuthorizeByCodeAsync uses correct key format.
    /// Key format must match the format used in GenerateAuthorizationCodeAsync.
    /// </summary>
    [Fact]
    public async Task AuthorizeByCodeAsync_ShouldUseCorrectKeyFormat()
    {
        // Arrange
        var code = "test_code";
        var grant = CreateGrant();

        _storage
            .Setup(s => s.GetAsync<AuthorizedGrant>(
                $"Abblix.Oidc.Server:Grant:{code}",
                false,
                It.IsAny<System.Threading.CancellationToken?>()))
            .ReturnsAsync(grant);

        // Act
        await _service.AuthorizeByCodeAsync(code);

        // Assert
        _storage.Verify(
            s => s.GetAsync<AuthorizedGrant>(
                $"Abblix.Oidc.Server:Grant:{code}",
                false,
                It.IsAny<System.Threading.CancellationToken?>()),
            Times.Once);
    }

    /// <summary>
    /// Verifies that RemoveAuthorizationCodeAsync calls storage.RemoveAsync.
    /// Per OAuth 2.0, authorization codes should be removed after use to prevent replay.
    /// </summary>
    [Fact]
    public async Task RemoveAuthorizationCodeAsync_ShouldCallStorageRemove()
    {
        // Arrange
        var code = "code_to_remove";

        _storage
            .Setup(s => s.RemoveAsync(
                It.IsAny<string>(),
                It.IsAny<System.Threading.CancellationToken?>()))
            .Returns(Task.CompletedTask);

        // Act
        await _service.RemoveAuthorizationCodeAsync(code);

        // Assert
        _storage.Verify(
            s => s.RemoveAsync(
                $"Abblix.Oidc.Server:Grant:{code}",
                It.IsAny<System.Threading.CancellationToken?>()),
            Times.Once);
    }

    /// <summary>
    /// Verifies that RemoveAuthorizationCodeAsync uses correct key format.
    /// Key format must be consistent with other methods.
    /// </summary>
    [Fact]
    public async Task RemoveAuthorizationCodeAsync_ShouldUseCorrectKeyFormat()
    {
        // Arrange
        var code = "test_code";
        string? capturedKey = null;

        _storage
            .Setup(s => s.RemoveAsync(
                It.IsAny<string>(),
                It.IsAny<System.Threading.CancellationToken?>()))
            .Callback<string, System.Threading.CancellationToken?>(
                (key, _) => capturedKey = key)
            .Returns(Task.CompletedTask);

        // Act
        await _service.RemoveAuthorizationCodeAsync(code);

        // Assert
        Assert.Equal($"Abblix.Oidc.Server:Grant:{code}", capturedKey);
    }

    /// <summary>
    /// Verifies that UpdateAuthorizationGrantAsync updates the stored grant.
    /// This allows updating grant information (e.g., after PKCE validation).
    /// </summary>
    [Fact]
    public async Task UpdateAuthorizationGrantAsync_ShouldUpdateGrant()
    {
        // Arrange
        var code = "existing_code";
        var updatedGrant = CreateGrant();
        var expiresIn = TimeSpan.FromMinutes(5);
        AuthorizedGrant? capturedGrant = null;

        _storage
            .Setup(s => s.SetAsync(
                It.IsAny<string>(),
                It.IsAny<AuthorizedGrant>(),
                It.IsAny<StorageOptions>(),
                It.IsAny<System.Threading.CancellationToken?>()))
            .Callback<string, AuthorizedGrant, StorageOptions, System.Threading.CancellationToken?>(
                (_, grant, _, _) => capturedGrant = grant)
            .Returns(Task.CompletedTask);

        // Act
        await _service.UpdateAuthorizationGrantAsync(code, updatedGrant, expiresIn);

        // Assert
        Assert.Same(updatedGrant, capturedGrant);
    }

    /// <summary>
    /// Verifies that UpdateAuthorizationGrantAsync uses correct key format.
    /// Key format must be consistent with other methods.
    /// </summary>
    [Fact]
    public async Task UpdateAuthorizationGrantAsync_ShouldUseCorrectKeyFormat()
    {
        // Arrange
        var code = "test_code";
        var grant = CreateGrant();
        var expiresIn = TimeSpan.FromMinutes(5);
        string? capturedKey = null;

        _storage
            .Setup(s => s.SetAsync(
                It.IsAny<string>(),
                It.IsAny<AuthorizedGrant>(),
                It.IsAny<StorageOptions>(),
                It.IsAny<System.Threading.CancellationToken?>()))
            .Callback<string, AuthorizedGrant, StorageOptions, System.Threading.CancellationToken?>(
                (key, _, _, _) => capturedKey = key)
            .Returns(Task.CompletedTask);

        // Act
        await _service.UpdateAuthorizationGrantAsync(code, grant, expiresIn);

        // Assert
        Assert.Equal($"Abblix.Oidc.Server:Grant:{code}", capturedKey);
    }

    /// <summary>
    /// Verifies that UpdateAuthorizationGrantAsync sets expiration.
    /// Updated grant should maintain expiration policy.
    /// </summary>
    [Fact]
    public async Task UpdateAuthorizationGrantAsync_ShouldSetExpiration()
    {
        // Arrange
        var code = "test_code";
        var grant = CreateGrant();
        var expiresIn = TimeSpan.FromMinutes(5);
        StorageOptions? capturedOptions = null;

        _storage
            .Setup(s => s.SetAsync(
                It.IsAny<string>(),
                It.IsAny<AuthorizedGrant>(),
                It.IsAny<StorageOptions>(),
                It.IsAny<System.Threading.CancellationToken?>()))
            .Callback<string, AuthorizedGrant, StorageOptions, System.Threading.CancellationToken?>(
                (_, _, options, _) => capturedOptions = options)
            .Returns(Task.CompletedTask);

        // Act
        await _service.UpdateAuthorizationGrantAsync(code, grant, expiresIn);

        // Assert
        Assert.NotNull(capturedOptions);
        Assert.Equal(expiresIn, capturedOptions!.AbsoluteExpirationRelativeToNow);
    }

    /// <summary>
    /// Verifies that UpdateAuthorizationGrantAsync overwrites previous data.
    /// SetAsync should replace existing grant with new data.
    /// </summary>
    [Fact]
    public async Task UpdateAuthorizationGrantAsync_ShouldOverwritePreviousData()
    {
        // Arrange
        var code = "test_code";
        var originalGrant = CreateGrant();
        var updatedGrant = CreateGrant();
        var expiresIn = TimeSpan.FromMinutes(5);

        _storage
            .Setup(s => s.SetAsync(
                It.IsAny<string>(),
                It.IsAny<AuthorizedGrant>(),
                It.IsAny<StorageOptions>(),
                It.IsAny<System.Threading.CancellationToken?>()))
            .Returns(Task.CompletedTask);

        // Act
        await _service.UpdateAuthorizationGrantAsync(code, originalGrant, expiresIn);
        await _service.UpdateAuthorizationGrantAsync(code, updatedGrant, expiresIn);

        // Assert
        _storage.Verify(
            s => s.SetAsync(
                $"Abblix.Oidc.Server:Grant:{code}",
                It.IsAny<AuthorizedGrant>(),
                It.IsAny<StorageOptions>(),
                It.IsAny<System.Threading.CancellationToken?>()),
            Times.Exactly(2));
    }

    /// <summary>
    /// Verifies integration: generate, authorize, and remove code flow.
    /// This simulates the complete authorization code lifecycle.
    /// </summary>
    [Fact]
    public async Task CompleteFlow_GenerateAuthorizeRemove_ShouldWorkCorrectly()
    {
        // Arrange
        var code = "flow_code";
        var grant = CreateGrant();
        var expiresIn = TimeSpan.FromMinutes(10);

        _codeGenerator
            .Setup(g => g.GenerateAuthorizationCode())
            .Returns(code);

        _storage
            .Setup(s => s.SetAsync(
                $"Abblix.Oidc.Server:Grant:{code}",
                grant,
                It.IsAny<StorageOptions>(),
                It.IsAny<System.Threading.CancellationToken?>()))
            .Returns(Task.CompletedTask);

        _storage
            .Setup(s => s.GetAsync<AuthorizedGrant>(
                $"Abblix.Oidc.Server:Grant:{code}",
                false,
                It.IsAny<System.Threading.CancellationToken?>()))
            .ReturnsAsync(grant);

        _storage
            .Setup(s => s.RemoveAsync(
                $"Abblix.Oidc.Server:Grant:{code}",
                It.IsAny<System.Threading.CancellationToken?>()))
            .Returns(Task.CompletedTask);

        // Act
        var generatedCode = await _service.GenerateAuthorizationCodeAsync(grant, expiresIn);
        var authorizeResult = await _service.AuthorizeByCodeAsync(generatedCode);
        await _service.RemoveAuthorizationCodeAsync(generatedCode);

        // Assert
        Assert.Equal(code, generatedCode);
        Assert.True(authorizeResult.TryGetSuccess(out var retrievedGrant));
        Assert.Same(grant, retrievedGrant);
        _storage.Verify(s => s.RemoveAsync($"Abblix.Oidc.Server:Grant:{code}", It.IsAny<System.Threading.CancellationToken?>()), Times.Once);
    }

    /// <summary>
    /// Verifies that after removal, authorization fails.
    /// Removed codes should no longer be valid.
    /// </summary>
    [Fact]
    public async Task AuthorizeByCodeAsync_AfterRemoval_ShouldReturnError()
    {
        // Arrange
        var code = "removed_code";

        _storage
            .Setup(s => s.GetAsync<AuthorizedGrant>(
                $"Abblix.Oidc.Server:Grant:{code}",
                false,
                It.IsAny<System.Threading.CancellationToken?>()))
            .ReturnsAsync((AuthorizedGrant?)null);

        // Act
        var result = await _service.AuthorizeByCodeAsync(code);

        // Assert
        Assert.True(result.TryGetFailure(out var error));
        Assert.Equal(ErrorCodes.InvalidGrant, error.Error);
    }

    /// <summary>
    /// Verifies that different codes map to different storage keys.
    /// Each code should have a unique storage location.
    /// </summary>
    [Fact]
    public async Task GenerateAuthorizationCodeAsync_DifferentCodes_ShouldUseDifferentKeys()
    {
        // Arrange
        var grant = CreateGrant();
        var expiresIn = TimeSpan.FromMinutes(10);
        var keys = new System.Collections.Generic.List<string>();

        _codeGenerator
            .SetupSequence(g => g.GenerateAuthorizationCode())
            .Returns("code_1")
            .Returns("code_2");

        _storage
            .Setup(s => s.SetAsync(
                It.IsAny<string>(),
                It.IsAny<AuthorizedGrant>(),
                It.IsAny<StorageOptions>(),
                It.IsAny<System.Threading.CancellationToken?>()))
            .Callback<string, AuthorizedGrant, StorageOptions, System.Threading.CancellationToken?>(
                (key, _, _, _) => keys.Add(key))
            .Returns(Task.CompletedTask);

        // Act
        await _service.GenerateAuthorizationCodeAsync(grant, expiresIn);
        await _service.GenerateAuthorizationCodeAsync(grant, expiresIn);

        // Assert
        Assert.Equal(2, keys.Count);
        Assert.NotEqual(keys[0], keys[1]);
        Assert.Equal("Abblix.Oidc.Server:Grant:code_1", keys[0]);
        Assert.Equal("Abblix.Oidc.Server:Grant:code_2", keys[1]);
    }

    /// <summary>
    /// Verifies that expiration time is respected.
    /// Different expiration times should be stored correctly.
    /// </summary>
    [Fact]
    public async Task GenerateAuthorizationCodeAsync_WithDifferentExpirations_ShouldStoreCorrectly()
    {
        // Arrange
        var grant = CreateGrant();
        var shortExpiration = TimeSpan.FromMinutes(1);
        var longExpiration = TimeSpan.FromMinutes(30);
        var expirations = new System.Collections.Generic.List<TimeSpan?>();

        _codeGenerator
            .SetupSequence(g => g.GenerateAuthorizationCode())
            .Returns("code_1")
            .Returns("code_2");

        _storage
            .Setup(s => s.SetAsync(
                It.IsAny<string>(),
                It.IsAny<AuthorizedGrant>(),
                It.IsAny<StorageOptions>(),
                It.IsAny<System.Threading.CancellationToken?>()))
            .Callback<string, AuthorizedGrant, StorageOptions, System.Threading.CancellationToken?>(
                (_, _, options, _) => expirations.Add(options.AbsoluteExpirationRelativeToNow))
            .Returns(Task.CompletedTask);

        // Act
        await _service.GenerateAuthorizationCodeAsync(grant, shortExpiration);
        await _service.GenerateAuthorizationCodeAsync(grant, longExpiration);

        // Assert
        Assert.Equal(2, expirations.Count);
        Assert.Equal(shortExpiration, expirations[0]);
        Assert.Equal(longExpiration, expirations[1]);
    }
}
